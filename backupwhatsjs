const wppconnect = require('@wppconnect-team/wppconnect');
const { db } = require('./database');
const fs = require('fs');
const path = require('path');

// Verifica√ß√£o inicial do Puppeteer (simplificada)
console.log('üîç Verificando Puppeteer...');
try {
  const puppeteer = require('puppeteer');
  console.log('‚úÖ Puppeteer dispon√≠vel - vers√£o:', puppeteer.version || 'N/A');
} catch (error) {
  console.error('‚ùå Puppeteer n√£o encontrado:', error.message);
}

// Armazenar clientes WhatsApp ativos
const sessions = new Map();

// Cache para controlar mensagens autom√°ticas (evitar spam)
const lastAutoMessages = new Map();

// Configura√ß√µes com Puppeteer otimizado e novo Headless
const config = {
  folderNameToken: 'tokens',
  mkdirFolderToken: true,
  headless: "new", // MUDAN√áA: Usar novo modo Headless
  devtools: false,
  useChrome: true,
  debug: false,
  logQR: false,
  browserWS: '',
  browserArgs: [
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--disable-dev-shm-usage',
    '--disable-accelerated-2d-canvas',
    '--no-first-run',
    '--no-zygote',
    '--disable-gpu',
    '--disable-web-security',
    '--disable-features=VizDisplayCompositor',
    '--disable-background-timer-throttling',
    '--disable-backgrounding-occluded-windows',
    '--disable-renderer-backgrounding',
    '--disable-extensions',
    '--disable-plugins',
    '--disable-default-apps',
    '--no-default-browser-check',
    '--disable-sync'
  ],
  puppeteerOptions: {
    headless: "new", // MUDAN√áA: Novo modo Headless
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox', 
      '--disable-dev-shm-usage',
      '--disable-gpu',
      '--disable-web-security',
      '--disable-features=VizDisplayCompositor',
      '--no-first-run',
      '--no-zygote',
      '--disable-background-timer-throttling',
      '--no-default-browser-check',
      '--disable-sync'
    ],
    ignoreDefaultArgs: ['--disable-extensions'],
    defaultViewport: { width: 1366, height: 768 },
    timeout: 60000
  },
  disableWelcome: true,
  updatesLog: false,
  autoClose: 60000,
  tokenStore: 'file'
};

// Classe para gerenciar WhatsApp
class WhatsAppService {
  constructor(io) {
    this.io = io;
    this.initialize();
    this.startCacheCleanup();
  }

  // M√©todo de inicializa√ß√£o ass√≠ncrono
  async initialize() {
    try {
      console.log('üöÄ Inicializando WhatsApp Service...');
      
      // Fazer limpeza primeiro
      await this.cleanupOnStart();
      
      // Depois inicializar sess√µes
      await this.initializeSessions();
      
      console.log('‚úÖ WhatsApp Service inicializado com sucesso');
    } catch (error) {
      console.error('‚ùå Erro na inicializa√ß√£o do WhatsApp Service:', error);
    }
  }

  // M√©todo para limpeza suave (sem matar processos)
  async killOrphanChromeProcesses() {
    try {
      console.log('üßπ Verificando processos Chrome √≥rf√£os...');
      // Apenas log - n√£o mata processos para evitar interferir com Chrome pessoal
      console.log('‚úÖ Limpeza suave conclu√≠da');
    } catch (error) {
      console.log('‚ö†Ô∏è Erro na verifica√ß√£o:', error.message);
    }
  }

  // Limpeza inicial ao iniciar o servi√ßo
  async cleanupOnStart() {
    try {
      console.log('üßπ Iniciando limpeza de recursos √≥rf√£os...');
      
      // Matar processos Chrome √≥rf√£os (com await)
      await this.killOrphanChromeProcesses();
      
      // Aguardar um pouco para garantir que os processos foram finalizados
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Limpar pastas de browser-data antigas
      const fs = require('fs');
      const path = require('path');
      
      const browserDataBaseDir = path.resolve('./browser-data');
      if (fs.existsSync(browserDataBaseDir)) {
        try {
          if (fs.rmSync) {
            fs.rmSync(browserDataBaseDir, { recursive: true, force: true });
          } else {
            // Fallback para vers√µes mais antigas do Node.js
            this.removeDirectoryRecursive(browserDataBaseDir);
          }
          console.log('üßπ Pasta browser-data limpa');
        } catch (rmError) {
          console.log('‚ö†Ô∏è Erro ao remover browser-data, tentando m√©todo alternativo...');
          this.removeDirectoryRecursive(browserDataBaseDir);
        }
      }
      
      // Limpar tokens antigos tamb√©m
      const tokensDir = path.resolve('./tokens');
      if (fs.existsSync(tokensDir)) {
        try {
          const tokenFolders = fs.readdirSync(tokensDir);
          for (const folder of tokenFolders) {
            const folderPath = path.join(tokensDir, folder);
            if (fs.statSync(folderPath).isDirectory()) {
              if (fs.rmSync) {
                fs.rmSync(folderPath, { recursive: true, force: true });
              } else {
                this.removeDirectoryRecursive(folderPath);
              }
              console.log(`üßπ Token folder limpo: ${folder}`);
            }
          }
        } catch (tokenError) {
          console.log('‚ö†Ô∏è Erro ao limpar tokens:', tokenError.message);
        }
      }
      
      // Recriar estrutura de pastas
      fs.mkdirSync(browserDataBaseDir, { recursive: true });
      fs.mkdirSync(tokensDir, { recursive: true });
      
      console.log('‚úÖ Limpeza inicial conclu√≠da com sucesso');
      
    } catch (error) {
      console.error('‚ùå Erro na limpeza inicial:', error);
      // N√£o falhar a inicializa√ß√£o por causa da limpeza
      console.log('‚ö†Ô∏è Continuando inicializa√ß√£o mesmo com erro na limpeza...');
    }
  }

  // Fun√ß√£o auxiliar para remo√ß√£o recursiva (compatibilidade)
  removeDirectoryRecursive(dirPath) {
    const fs = require('fs');
    const path = require('path');
    
    try {
      if (fs.existsSync(dirPath)) {
        const files = fs.readdirSync(dirPath);
        files.forEach((file) => {
          const currentPath = path.join(dirPath, file);
          if (fs.lstatSync(currentPath).isDirectory()) {
            this.removeDirectoryRecursive(currentPath); // Recurs√£o
          } else {
            fs.unlinkSync(currentPath); // Remover arquivo
          }
        });
        fs.rmdirSync(dirPath); // Remover diret√≥rio vazio
        console.log(`üßπ Diret√≥rio removido: ${dirPath}`);
      }
    } catch (error) {
      console.error(`‚ùå Erro ao remover diret√≥rio ${dirPath}:`, error.message);
    }
  }

  // Inicializar sess√µes existentes
  async initializeSessions() {
    try {
      const dbSessions = await db.sessions.list();
      for (const session of dbSessions) {
        if (session.status === 'connected') {
          // Tentar reconectar sess√µes que estavam conectadas
          this.createSession(session.id, session.name);
        }
      }
    } catch (error) {
      console.error('Erro ao inicializar sess√µes:', error);
    }
  }

  // Criar nova sess√£o com isolamento para m√∫ltiplas inst√¢ncias
  async createSession(sessionId, sessionName) {
    try {
      console.log(`üîÑ Iniciando sess√£o: ${sessionName}`);
      
      // Atualizar status no banco
      await db.sessions.update(sessionId, { status: 'connecting' });
      
      // Configura√ß√£o espec√≠fica para esta sess√£o (ISOLAMENTO)
      const sessionConfig = {
        ...config,
        session: sessionName,
        folderNameToken: `tokens/${sessionName}`, // Pasta espec√≠fica
        puppeteerOptions: {
          ...config.puppeteerOptions,
          userDataDir: `./browser-data/${sessionName}`, // Dados √∫nicos do browser
          args: [
            ...config.browserArgs,
            `--user-data-dir=./browser-data/${sessionName}`, // Isolamento completo
            `--remote-debugging-port=${9222 + sessionId}` // Porta √∫nica por sess√£o
          ]
        },
        browserArgs: [
          ...config.browserArgs,
          `--user-data-dir=./browser-data/${sessionName}`,
          `--remote-debugging-port=${9222 + sessionId}`,
          `--profile-directory=Profile${sessionId}` // Perfil √∫nico
        ],
        statusFind: (statusSession, session) => {
          console.log(`Status da sess√£o ${sessionName}: ${statusSession}`);
          this.handleStatus(sessionId, statusSession);
        },
        catchQR: (base64Qr, asciiQR) => {
          console.log(`üì± QR Code gerado para ${sessionName}`);
          this.handleQRCode(sessionId, base64Qr);
        }
      };

      // Garantir que a pasta existe
      const fs = require('fs');
      const path = require('path');
      const browserDataDir = `./browser-data/${sessionName}`;
      if (!fs.existsSync(browserDataDir)) {
        fs.mkdirSync(browserDataDir, { recursive: true });
        console.log(`üìÅ Pasta criada: ${browserDataDir}`);
      }
      
      // Configurar callbacks
      const client = await wppconnect.create(sessionConfig);

      // Armazenar cliente
      sessions.set(sessionId, {
        client,
        name: sessionName,
        status: 'connected'
      });

      // Configurar listeners
      this.setupListeners(sessionId, client);

      // Atualizar status no banco
      const info = await client.getHostDevice();
      await db.sessions.update(sessionId, {
        status: 'connected',
        number: info.id.user,
        connected_at: new Date()
      });

      // Emitir evento de conex√£o
      this.io.emit('session:connected', {
        sessionId,
        sessionName,
        number: info.id.user
      });

      console.log(`‚úÖ Sess√£o ${sessionName} conectada!`);
      return client;

    } catch (error) {
      console.error(`‚ùå Erro ao criar sess√£o ${sessionName}:`, error);
      await db.sessions.update(sessionId, { status: 'disconnected' });
      throw error;
    }
  }

  // Configurar listeners de mensagens
  setupListeners(sessionId, client) {
    // Mensagens recebidas
    client.onMessage(async (message) => {
      try {
        await this.handleIncomingMessage(sessionId, message);
      } catch (error) {
        console.error('Erro ao processar mensagem:', error);
      }
    });

    // Status da mensagem
    client.onAck(async (ack) => {
      this.io.emit('message:ack', {
        sessionId,
        messageId: ack.id,
        status: ack.ack
      });
    });

    // Presen√ßa (digitando)
    client.onPresenceChanged((presenceData) => {
      this.io.emit('contact:presence', {
        sessionId,
        number: presenceData.id,
        presence: presenceData.isOnline ? 'online' : 'offline',
        lastSeen: presenceData.t
      });
    });

    // Estado da conex√£o
    client.onStateChange((state) => {
      console.log(`Estado da sess√£o ${sessionId}: ${state}`);
      if (state === 'CONFLICT' || state === 'UNPAIRED' || state === 'UNLAUNCHED') {
        this.handleDisconnect(sessionId);
      }
    });
  }

  // Buscar avatar com m√∫ltiplas tentativas e m√©todos
  async getContactAvatarWithRetry(client, number, contactName, maxRetries = 3) {
    console.log(`üîç Buscando avatar para: ${contactName || number}`);
    
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        // Delay progressivo entre tentativas
        if (attempt > 0) {
          await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
          console.log(`üîÑ Tentativa ${attempt + 1} para ${contactName || number}`);
        }
        
        // M√©todo 1: getProfilePicFromServer
        try {
          const avatarUrl = await client.getProfilePicFromServer(number);
          if (avatarUrl && typeof avatarUrl === 'string' && avatarUrl.startsWith('http')) {
            console.log(`‚úÖ Avatar encontrado (m√©todo 1): ${contactName || number}`);
            return avatarUrl;
          }
        } catch (e) {
          console.log(`‚ö†Ô∏è M√©todo 1 falhou: ${e.message}`);
        }
        
        // M√©todo 2: getContact com fallback
        try {
          const contact = await client.getContact(number);
          if (contact && contact.profilePicThumbObj && contact.profilePicThumbObj.eurl) {
            console.log(`‚úÖ Avatar encontrado (m√©todo 2): ${contactName || number}`);
            return contact.profilePicThumbObj.eurl;
          }
        } catch (e) {
          console.log(`‚ö†Ô∏è M√©todo 2 falhou: ${e.message}`);
        }
        
        // M√©todo 3: Buscar dados do perfil
        try {
          const profilePic = await client.getProfilePicUrl(number);
          if (profilePic && profilePic !== 'undefined') {
            console.log(`‚úÖ Avatar encontrado (m√©todo 3): ${contactName || number}`);
            return profilePic;
          }
        } catch (e) {
          console.log(`‚ö†Ô∏è M√©todo 3 falhou: ${e.message}`);
        }
        
      } catch (error) {
        console.log(`‚ùå Tentativa ${attempt + 1} falhou para ${contactName || number}: ${error.message}`);
      }
    }
    
    console.log(`‚ùå Sem avatar dispon√≠vel: ${contactName || number} (ap√≥s ${maxRetries} tentativas)`);
    return null;
  }

  // Processar mensagem recebida - VERS√ÉO CORRIGIDA
  async handleIncomingMessage(sessionId, message) {
    console.log('Mensagem recebida:', message.from, message.body?.substring(0, 50) || '[M√≠dia]');
    console.log('Tipo de mensagem:', message.type, 'Mimetype:', message.mimetype);
    
    // Ignorar mensagens de grupos e status
    if (message.isGroupMsg || message.isStatusReply) return;

    // Buscar ou criar contato
    const contact = await db.contacts.findOrCreate(
      message.from,
      message.sender?.pushname || message.sender?.verifiedName || message.from.split('@')[0]
    );

    // Buscar/atualizar avatar sempre (pode ter mudado)
    // Buscar/atualizar avatar com retry melhorado
    try {
      const session = sessions.get(sessionId);
      if (session && session.client) {
        // S√≥ buscar avatar se n√£o tiver ou for muito antigo (7 dias)
        const shouldUpdateAvatar = !contact.avatar || 
          !contact.avatar_updated_at || 
          (new Date() - new Date(contact.avatar_updated_at)) > (7 * 24 * 60 * 60 * 1000);
        
        if (shouldUpdateAvatar) {
          const avatarUrl = await this.getContactAvatarWithRetry(
            session.client, 
            message.from, 
            contact.name || contact.number
          );
          
          if (avatarUrl && contact.avatar !== avatarUrl) {
            await db.contacts.update(contact.id, { 
              avatar: avatarUrl,
              avatar_updated_at: new Date()
            });
            contact.avatar = avatarUrl;

            console.log(`‚úÖ Avatar atualizado para ${contact.name || contact.number}`);
            console.log(`üì∏ URL: ${avatarUrl.substring(0, 100)}...`);

            // Notificar o frontend em tempo real
            this.io.emit('contact:update', {
              id: contact.id,
              avatar: avatarUrl
            });
          }
        }
      }
    } catch (err) {
      console.error('Falha ao obter avatar:', err.message);
    }

    // Atualizar √∫ltima mensagem do contato
    await db.contacts.update(contact.id, {
      last_message: message.body?.substring(0, 100) || '[M√≠dia]',
      last_message_at: new Date()
    });

   // Determinar tipo da mensagem e processar conte√∫do
    let messageType = 'text';
    let mediaUrl = null;
    let finalContent = message.body || '';

    console.log('üîç PROCESSANDO MENSAGEM:', {
      type: message.type,
      mimetype: message.mimetype,
      hasBody: !!message.body,
      bodyLength: message.body?.length || 0,
      hasCaption: !!message.caption,
      isMedia: !!message.isMedia
    });

    // Identificar tipo de m√≠dia - VERS√ÉO CORRIGIDA E SIMPLIFICADA
    if (message.type === 'image') {
      messageType = 'image';
      finalContent = message.caption || '';
    } else if (message.type === 'video') {
      messageType = 'video';
      finalContent = message.caption || '';
    } else if (message.type === 'audio' || message.type === 'ptt') {
      messageType = 'audio';
      finalContent = '';
    } else if (message.type === 'document') {
      messageType = 'document';
      finalContent = message.caption || message.filename || 'Documento';
    } else if (message.type === 'location') {
      messageType = 'location';
      if (message.lat && message.lng) {
        finalContent = `üìç Localiza√ß√£o compartilhada\nLatitude: ${message.lat}\nLongitude: ${message.lng}`;
        if (message.loc) {
          finalContent += `\nEndere√ßo: ${message.loc}`;
        }
      } else {
        finalContent = 'üìç Localiza√ß√£o compartilhada';
      }
    } else if (message.type === 'vcard' || message.type === 'contact_card') {
      messageType = 'contact';
      if (message.vcardList && message.vcardList.length > 0) {
        const contact = message.vcardList[0];
        finalContent = `üë§ Contato compartilhado\nNome: ${contact.displayName || contact.formattedName || 'N/A'}`;
        if (contact.vcard) {
          const phoneMatch = contact.vcard.match(/TEL[^:]*:([^\r\n]+)/);
          if (phoneMatch) {
            finalContent += `\nTelefone: ${phoneMatch[1]}`;
          }
        }
      } else {
        finalContent = 'üë§ Contato compartilhado';
      }
    } else if (message.type === 'sticker') {
      messageType = 'sticker';
      finalContent = '';
    }

    // Processar m√≠dia - L√ìGICA COMPLETAMENTE REESCRITA
    if (['image', 'video', 'audio', 'document', 'sticker'].includes(messageType)) {
      console.log('üìé Processando m√≠dia:', messageType);
      
      try {
        // SEMPRE tentar fazer download primeiro
        message.sessionId = sessionId;
        mediaUrl = await this.downloadMedia(message);
        
        if (mediaUrl) {
          console.log('‚úÖ M√≠dia baixada com sucesso:', mediaUrl);
        } else {
          console.log('‚ö†Ô∏è Download falhou, tentando alternativas...');
          
          // Fallback 1: Base64 para imagens pequenas/m√©dias
          if ((messageType === 'image' || messageType === 'sticker') && 
              message.body && 
              message.body.length > 500 && 
              message.body.length < 5000000) { // At√© 5MB
            
            // Verificar se √© base64 v√°lido
            const base64Pattern = /^[A-Za-z0-9+/]+=*$/;
            if (base64Pattern.test(message.body)) {
              mediaUrl = `data:${message.mimetype || 'image/jpeg'};base64,${message.body}`;
              console.log('üîÑ Usando base64 como fallback');
            }
          }
          
          // Fallback 2: √Åudio em base64
          if (messageType === 'audio' && message.body && message.body.length > 1000) {
            const base64Pattern = /^[A-Za-z0-9+/]+=*$/;
            if (base64Pattern.test(message.body)) {
              mediaUrl = `data:${message.mimetype || 'audio/ogg'};base64,${message.body}`;
              console.log('üîÑ √Åudio base64 usado como fallback');
            }
          }
          
          // Se ainda n√£o tem mediaUrl, marcar como erro
          if (!mediaUrl) {
            console.log('‚ùå Falha total ao processar m√≠dia');
            finalContent = `[${messageType.toUpperCase()} - Erro ao baixar]`;
          }
        }
        
      } catch (error) {
        console.error('‚ùå Erro ao processar m√≠dia:', error);
        finalContent = `[${messageType.toUpperCase()} - Erro: ${error.message}]`;
      }
    }

    // Salvar mensagem no banco
    const messageId = await db.messages.create({
      session_id: sessionId,
      contact_id: contact.id,
      content: finalContent,
      type: messageType,
      media_url: mediaUrl,
      is_from_me: false,
      status: 'received'
    });

    // Incrementar contador de n√£o lidas
    await db.query(
      'UPDATE contacts SET unread_count = unread_count + 1 WHERE id = ?',
      [contact.id]
    );

    // Verificar se contato est√° em atendimento
    const activeQueue = await db.query(
      'SELECT * FROM queues WHERE contact_id = ? AND status IN (?, ?) ORDER BY id DESC LIMIT 1',
      [contact.id, 'waiting', 'attending']
    );

   // Verificar se h√° enquete ativa para este contato
    const activePoll = await this.checkActivePoll(contact.id, message.body);
    
    // Se n√£o est√° em atendimento, adicionar √† fila
    if (activeQueue.length === 0 && !activePoll) {
      const sector = await this.determineSector(message.body || '');
      
      // Criar fila primeiro
      const queueId = await db.queues.create(contact.id, sector);
      
      // **CORRE√á√ÉO: SEMPRE TENTAR ENVIAR MENSAGEM DE BOAS-VINDAS**
      try {
        // Verificar se mensagens autom√°ticas est√£o habilitadas
        const { db: database } = require('./database');
        const autoSettings = await database.settings.getAutoMessages();
        
        if (autoSettings.welcome.enabled) {
          // Verificar hor√°rio comercial
          const { businessHoursHelpers } = require('./auth');
          const isBusinessTime = await businessHoursHelpers.isBusinessHours();
          
          if (!isBusinessTime && autoSettings.welcome.businessHoursOnly) {
            // Fora do hor√°rio: usar mensagem de hor√°rio comercial OU mensagem espec√≠fica
            if (autoSettings.welcome.afterHoursMessage) {
              await this.sendWelcomeMessage(sessionId, message.from, false); // false = fora do hor√°rio
            } else {
              await this.sendBusinessHoursMessage(sessionId, message.from);
            }
          } else {
            // Dentro do hor√°rio: enviar mensagem de boas-vindas normal
            await this.sendWelcomeMessage(sessionId, message.from, true); // true = hor√°rio comercial
          }
          
          console.log(`‚úÖ Mensagem autom√°tica enviada para ${contact.number} - setor ${sector}`);
        } else {
          console.log(`‚ÑπÔ∏è Mensagens de boas-vindas desabilitadas - ${contact.number}`);
        }
      } catch (welcomeError) {
        console.error('‚ùå Erro ao enviar mensagem de boas-vindas:', welcomeError);
      }
      
      console.log(`Contato ${contact.number} adicionado √† fila do setor ${sector}`);
    }

    // Emitir evento para frontend
    this.io.emit('message:received', {
      sessionId,
      messageId,
      contact: {
        id: contact.id,
        number: contact.number,
        name: contact.name
      },
      message: {
        content: finalContent,
        type: messageType,
        mediaUrl: mediaUrl,
        timestamp: new Date()
      }
    });
  }

  // Determinar setor baseado no conte√∫do
  async determineSector(content) {
    if (!content) return 'Geral';

    const lowerContent = content.toLowerCase();
    
    // Palavras-chave por setor
    const keywords = {
      'Medicamento': ['remedio', 'medicamento', 'receita', 'generico', 'farmaco', 'comprimido', 'capsula'],
      'Perfumaria 1': ['perfume', 'cosm√©tico', 'shampoo', 'creme', 'hidratante', 'sabonete'],
      'Perfumaria 2': ['maquiagem', 'batom', 'base', 'r√≠mel', 'sombra', 'blush'],
      'Suplementos': ['vitamina', 'suplemento', 'whey', 'proteina', 'creatina', 'omega'],
      'Dermocosm√©ticos': ['dermatite', 'acne', 'pele', 'dermatologico', 'antienvelhecimento'],
      'Caixa': ['pagar', 'pagamento', 'valor', 'pre√ßo', 'quanto', 'custo', 'desconto']
    };

    for (const [sector, words] of Object.entries(keywords)) {
      if (words.some(word => lowerContent.includes(word))) {
        return sector;
      }
    }

    return 'Geral';
  }

  // Baixar m√≠dia - VERS√ÉO CORRIGIDA E ROBUSTA
  async downloadMedia(message) {
    try {
      const session = sessions.get(message.sessionId);
      if (!session || !session.client) {
        console.error('‚ùå Sess√£o n√£o encontrada para baixar m√≠dia');
        return null;
      }

      console.log('üì• Tentando baixar m√≠dia...', {
        type: message.type,
        mimetype: message.mimetype,
        hasId: !!message.id
      });

      // Tentar diferentes m√©todos de download
      let buffer = null;
      
      // M√©todo 1: decryptFile (padr√£o)
      try {
        buffer = await session.client.decryptFile(message);
        console.log('‚úÖ Download via decryptFile bem-sucedido');
      } catch (decryptError) {
        console.log('‚ö†Ô∏è decryptFile falhou:', decryptError.message);
        
        // M√©todo 2: downloadMedia (alternativo)
        try {
          buffer = await session.client.downloadMedia(message);
          console.log('‚úÖ Download via downloadMedia bem-sucedido');
        } catch (downloadError) {
          console.log('‚ö†Ô∏è downloadMedia tamb√©m falhou:', downloadError.message);
          
          // M√©todo 3: getFileBuffer (se dispon√≠vel)
          try {
            if (session.client.getFileBuffer) {
              buffer = await session.client.getFileBuffer(message.id);
              console.log('‚úÖ Download via getFileBuffer bem-sucedido');
            }
          } catch (bufferError) {
            console.log('‚ö†Ô∏è getFileBuffer falhou:', bufferError.message);
          }
        }
      }
      
      if (!buffer || buffer.length === 0) {
        console.error('‚ùå Todos os m√©todos de download falharam');
        return null;
      }

      // Determinar extens√£o baseada no mimetype
      let extension = 'bin';
      if (message.mimetype) {
        const mimetypeLower = message.mimetype.toLowerCase();
        
        // Mapeamento mais completo de mimetypes
        const extensionMap = {
          'image/jpeg': 'jpg',
          'image/jpg': 'jpg',
          'image/png': 'png',
          'image/gif': 'gif',
          'image/webp': 'webp',
          'image/bmp': 'bmp',
          'video/mp4': 'mp4',
          'video/webm': 'webm',
          'video/ogg': 'ogv',
          'video/quicktime': 'mov',
          'video/avi': 'avi',
          'audio/ogg': 'ogg',
          'audio/mpeg': 'mp3',
          'audio/mp3': 'mp3',
          'audio/wav': 'wav',
          'audio/aac': 'aac',
          'audio/webm': 'webm',
          'application/pdf': 'pdf',
          'application/msword': 'doc',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx',
          'application/vnd.ms-excel': 'xls',
          'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'xlsx',
          'text/plain': 'txt'
        };
        
        extension = extensionMap[mimetypeLower];
        
        if (!extension) {
          // Fallback para extrair da segunda parte do mimetype
          const parts = mimetypeLower.split('/');
          if (parts.length > 1) {
            extension = parts[1].split(';')[0]; // Remove par√¢metros extras
            extension = extension.replace(/[^a-zA-Z0-9]/g, '').substring(0, 10) || 'bin';
          }
        }
      }
      
      // Determinar extens√£o por tipo de mensagem se mimetype falhar
      if (extension === 'bin') {
        const typeExtensions = {
          'image': 'jpg',
          'video': 'mp4',
          'audio': 'ogg',
          'document': 'pdf',
          'sticker': 'webp'
        };
        extension = typeExtensions[message.type] || 'bin';
      }
      
      // Gerar nome √∫nico do arquivo
      const timestamp = Date.now();
      const randomId = Math.random().toString(36).substring(2, 8);
      const messageId = message.id ? message.id.replace(/[^a-zA-Z0-9]/g, '').substring(0, 8) : randomId;
      const filename = `${timestamp}_${messageId}.${extension}`;
      const filepath = path.join(__dirname, 'uploads', filename);
      
      // Garantir que a pasta uploads existe
      const uploadsDir = path.join(__dirname, 'uploads');
      if (!fs.existsSync(uploadsDir)) {
        fs.mkdirSync(uploadsDir, { recursive: true });
        console.log('üìÅ Pasta uploads criada');
      }
      
      // Salvar arquivo
      fs.writeFileSync(filepath, buffer);
      const fileSizeMB = (buffer.length / 1024 / 1024).toFixed(2);
      console.log(`‚úÖ M√≠dia salva: ${filename} (${fileSizeMB}MB)`);
      
      return `/uploads/${filename}`;
      
    } catch (error) {
      console.error('‚ùå Erro geral ao baixar m√≠dia:', error);
      return null;
    }
  }

  // Enviar mensagem de boas-vindas
  async sendWelcomeMessage(sessionId, to, isBusinessTime = null) {
    try {
      // Verificar se j√° enviou mensagem recentemente (√∫ltimos 5 minutos)
      const lastMessageKey = `welcome_${to}`;
      const lastMessageTime = lastAutoMessages.get(lastMessageKey);
      const now = Date.now();
      
      if (lastMessageTime && (now - lastMessageTime) < 300000) { // 5 minutos
        console.log(`Mensagem de boas-vindas j√° enviada recentemente para ${to}`);
        return;
      }

      // Mensagem padr√£o como fallback
      let welcomeMessage = 'üëã Ol√°! Bem-vindo ao nosso atendimento. Em breve um de nossos atendentes ir√° lhe atender.';
      let messageEnabled = true;
      let messageDelay = 0;
      
      // Se isBusinessTime n√£o foi passado, verificar automaticamente
      if (isBusinessTime === null) {
        try {
          const { businessHoursHelpers } = require('./auth');
          isBusinessTime = await businessHoursHelpers.isBusinessHours();
        } catch (timeError) {
          console.log('‚ö†Ô∏è Erro ao verificar hor√°rio, assumindo hor√°rio comercial');
          const hour = new Date().getHours();
          isBusinessTime = hour >= 8 && hour < 18;
        }
      }
      
      try {
        // **CORRE√á√ÉO: For√ßar recarregamento das configura√ß√µes sem cache**
        delete require.cache[require.resolve('./database')];
        const database = require('./database');
        
        console.log('üîÑ Recarregando configura√ß√µes de boas-vindas...');
        const autoSettings = await database.db.settings.getAutoMessages();
        
        console.log('üìã Configura√ß√µes carregadas:', {
          enabled: autoSettings.welcome.enabled,
          message: autoSettings.welcome.message?.substring(0, 50) + '...',
          afterHours: autoSettings.welcome.afterHoursMessage?.substring(0, 50) + '...'
        });
        
        // Aplicar configura√ß√µes se carregadas com sucesso
        messageEnabled = autoSettings.welcome.enabled;
        if (autoSettings.welcome.message) {
          welcomeMessage = autoSettings.welcome.message;
          console.log('‚úÖ Mensagem de boas-vindas atualizada');
        }
        if (autoSettings.welcome.afterHoursMessage) {
          afterHoursMessage = autoSettings.welcome.afterHoursMessage;
          console.log('‚úÖ Mensagem fora do hor√°rio atualizada');
        }
        messageDelay = autoSettings.advanced.messageDelay || 0;
        
        // Verificar hor√°rio comercial
        try {
          const authHelpers = require('./auth');
          isBusinessTime = await authHelpers.businessHoursHelpers.isBusinessHours();
        } catch (timeError) {
          console.log('‚ö†Ô∏è Erro ao verificar hor√°rio comercial, assumindo hor√°rio comercial');
          const hour = new Date().getHours();
          isBusinessTime = hour >= 8 && hour < 18;
        }
        
        console.log('üìã Configura√ß√µes de boas-vindas carregadas');
      } catch (configError) {
        console.log('‚ö†Ô∏è Usando configura√ß√µes padr√£o:', configError.message);
        const hour = new Date().getHours();
        isBusinessTime = hour >= 8 && hour < 18;
      }
      
      // Se mensagens est√£o desabilitadas
      if (!messageEnabled) {
        console.log('‚ÑπÔ∏è Mensagens de boas-vindas desabilitadas');
        return;
      }
      
      // Escolher mensagem baseada no hor√°rio
      let finalMessage = isBusinessTime ? welcomeMessage : afterHoursMessage;
      
      // Processar vari√°veis b√°sicas
      const saudacao = this.getSaudacao();
      finalMessage = finalMessage
        .replace(/\{\{nome\}\}/g, 'Cliente')
        .replace(/\{\{saudacao\}\}/g, saudacao)
        .replace(/\{\{data\}\}/g, new Date().toLocaleDateString('pt-BR'))
        .replace(/\{\{hora\}\}/g, new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }));
      
      console.log(`üì§ Enviando boas-vindas (${isBusinessTime ? 'comercial' : 'fora do hor√°rio'})`);
      
      // Aplicar delay se configurado
      if (messageDelay > 0) {
        await new Promise(resolve => setTimeout(resolve, messageDelay * 1000));
      }
      
      // Enviar mensagem
      await this.sendMessage(sessionId, to, finalMessage);
      
      // Registrar que enviou a mensagem
      lastAutoMessages.set(lastMessageKey, now);
      console.log(`‚úÖ Mensagem de boas-vindas enviada para ${to}`);
      
    } catch (error) {
      console.error('‚ùå Erro ao enviar mensagem de boas-vindas:', error);
    }
  }

  // Fun√ß√£o auxiliar para obter sauda√ß√£o
  getSaudacao() {
    const hour = new Date().getHours();
    if (hour >= 5 && hour < 12) return 'Bom dia';
    if (hour >= 12 && hour < 18) return 'Boa tarde';
    return 'Boa noite';
  }

  // Enviar mensagem de encerramento
  async sendGoodbyeMessage(sessionId, to, userSignature = null) {
    try {
      // Mensagem padr√£o como fallback
      let goodbyeMessage = 'üëã Agradecemos seu contato! Caso precise de algo mais, estamos √† disposi√ß√£o.';
      let messageEnabled = true;
      let includeSignature = false;
      let includeRating = false;
      let messageDelay = 0;
      
      try {
        // **CORRE√á√ÉO: For√ßar recarregamento das configura√ß√µes sem cache**
        delete require.cache[require.resolve('./database')];
        const database = require('./database');
        
        console.log('üîÑ Recarregando configura√ß√µes de despedida...');
        const autoSettings = await database.db.settings.getAutoMessages();
        
        console.log('üìã Configura√ß√µes carregadas:', {
          enabled: autoSettings.goodbye.enabled,
          message: autoSettings.goodbye.message?.substring(0, 50) + '...',
          includeSignature: autoSettings.goodbye.includeSignature,
          includeRating: autoSettings.goodbye.includeRating
        });
        
        // Aplicar configura√ß√µes se carregadas com sucesso
        messageEnabled = autoSettings.goodbye.enabled;
        if (autoSettings.goodbye.message) {
          goodbyeMessage = autoSettings.goodbye.message;
          console.log('‚úÖ Mensagem de despedida atualizada');
        }
        includeSignature = autoSettings.goodbye.includeSignature;
        includeRating = autoSettings.goodbye.includeRating;
        messageDelay = autoSettings.advanced.messageDelay || 0;
        
        console.log('üìã Configura√ß√µes de despedida aplicadas');
      } catch (configError) {
        console.log('‚ö†Ô∏è Usando configura√ß√µes padr√£o de despedida:', configError.message);
      }
      
      // Se mensagens est√£o desabilitadas
      if (!messageEnabled) {
        console.log('‚ÑπÔ∏è Mensagens de despedida desabilitadas');
        return;
      }
      
      // Processar vari√°veis b√°sicas
      const saudacao = this.getSaudacao();
      let finalMessage = goodbyeMessage
        .replace(/\{\{nome\}\}/g, 'Cliente')
        .replace(/\{\{saudacao\}\}/g, saudacao)
        .replace(/\{\{data\}\}/g, new Date().toLocaleDateString('pt-BR'))
        .replace(/\{\{hora\}\}/g, new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }));
      
      // Adicionar avalia√ß√£o se habilitado
      if (includeRating) {
        finalMessage += '\n\n‚≠ê Avalie nosso atendimento de 1 a 5 estrelas!';
      }
      
      // Preparar op√ß√µes de envio
      const sendOptions = {};
      if (includeSignature && userSignature) {
        sendOptions.signature = userSignature;
      }
      
      console.log('üì§ Enviando mensagem de despedida');
      
      // Aplicar delay se configurado
      if (messageDelay > 0) {
        await new Promise(resolve => setTimeout(resolve, messageDelay * 1000));
      }
      
      // Enviar mensagem
      await this.sendMessage(sessionId, to, finalMessage, sendOptions);
      
      console.log(`‚úÖ Mensagem de despedida enviada para ${to}`);
      
    } catch (error) {
      console.error('‚ùå Erro ao enviar mensagem de despedida:', error);
      
      // Fallback: enviar mensagem b√°sica
      try {
        await this.sendMessage(sessionId, to, 'üëã Agradecemos seu contato! Caso precise de algo mais, estamos √† disposi√ß√£o.');
        console.log(`‚úÖ Mensagem de despedida fallback enviada para ${to}`);
      } catch (fallbackError) {
        console.error('‚ùå Erro no fallback da mensagem de despedida:', fallbackError);
      }
    }
  }

  // Enviar mensagem de hor√°rio comercial
  async sendBusinessHoursMessage(sessionId, to) {
    try {
      // Verificar se j√° enviou mensagem recentemente (√∫ltimos 30 minutos)
      const lastMessageKey = `business_hours_${to}`;
      const lastMessageTime = lastAutoMessages.get(lastMessageKey);
      const now = Date.now();
      
      if (lastMessageTime && (now - lastMessageTime) < 1800000) { // 30 minutos
        console.log(`Mensagem de hor√°rio comercial j√° enviada recentemente para ${to}`);
        return;
      }
      
      const { businessHoursHelpers } = require('./auth');
      
      // Obter mensagem configurada
      let message = await db.settings.get('business_hours_message');
      
      if (!message) {
        // Mensagem padr√£o se n√£o configurada
        message = 'üè™ Ol√°! Nossa farm√°cia est√° fechada no momento.\n\nüìÖ Hor√°rio de funcionamento:\nSegunda a Sexta: 8h √†s 18h\nS√°bado: 8h √†s 12h\n\nüìù Sua mensagem foi registrada e responderemos assim que poss√≠vel.';
      }
      
      // Processar vari√°veis na mensagem
      message = await businessHoursHelpers.processBusinessHoursMessage(message);
      
      await this.sendMessage(sessionId, to, message, {
        signature: 'Sistema Autom√°tico'
      });
      
      // Registrar que enviou a mensagem
      lastAutoMessages.set(lastMessageKey, now);
      console.log(`‚úÖ Mensagem de hor√°rio comercial enviada para ${to}`);
      
    } catch (error) {
      console.error('‚ùå Erro ao enviar mensagem de hor√°rio comercial:', error);
    }
  }

  // Enviar mensagem - VERS√ÉO MELHORADA
  async sendMessage(sessionId, to, content, options = {}) {
    try {
      const session = sessions.get(sessionId);
      if (!session || !session.client) {
        throw new Error('Sess√£o n√£o encontrada ou desconectada');
      }

      let result;
      
      console.log('üì§ Enviando mensagem:', { 
        to: to.substring(0, 20) + '...', 
        type: options.type || 'text', 
        hasPath: !!options.path,
        contentLength: content?.length || 0
      });
      
      // Enviar baseado no tipo
      if (options.type === 'image' && options.path) {
        console.log('üñºÔ∏è Enviando imagem:', options.path);
        result = await session.client.sendImage(to, options.path, options.filename || 'image', content || '');
        
      } else if (options.type === 'document' && options.path) {
        console.log('üìÑ Enviando documento:', options.path);
        
        // Verificar se √© √°udio sendo enviado como documento
        const isAudio = options.filename && 
                       (options.filename.includes('audio') || 
                        options.path.includes('audio') ||
                        options.filename.match(/\.(ogg|mp3|wav|webm|m4a)$/i));
        
        if (isAudio) {
          console.log('üéµ √Åudio detectado - enviando link para reprodu√ß√£o');
          
          // Extrair nome do arquivo para criar link p√∫blico
          const filename = options.path.split('\\').pop().split('/').pop();
          const audioUrl = `${process.env.BASE_URL || 'http://localhost:3000'}/uploads/${filename}`;
          
          // Enviar link para o √°udio
          result = await session.client.sendText(
            to, 
            `üéµ *Mensagem de Voz*\n\nüîó Clique para ouvir: ${audioUrl}\n\n_Ou acesse o link no seu navegador para reproduzir o √°udio_`
          );
          console.log('‚úÖ Link de √°udio enviado:', audioUrl);
        } else {
          result = await session.client.sendFile(to, options.path, options.filename || 'document', content || '');
        }
        
      } else if (options.type === 'audio' && options.path) {
        console.log('üéµ Enviando √°udio:', options.path);
        
        const fs = require('fs');
        const path = require('path');
        
        // Verificar se arquivo existe
        if (!fs.existsSync(options.path)) {
          throw new Error('Arquivo de √°udio n√£o encontrado: ' + options.path);
        }
        
        const fileExtension = path.extname(options.path).toLowerCase();
        console.log('üìÅ Extens√£o do arquivo:', fileExtension);
        
        try {
          console.log('üéµ Enviando √°udio como mensagem de voz...');
          
          // Ler arquivo como base64
          const audioBuffer = fs.readFileSync(options.path);
          const audioBase64 = audioBuffer.toString('base64');
          
          // Determinar mimetype correto
          let mimeType = 'audio/ogg; codecs=opus';
          if (fileExtension === '.mp3') {
            mimeType = 'audio/mpeg';
          } else if (fileExtension === '.wav') {
            mimeType = 'audio/wav';
          } else if (fileExtension === '.m4a') {
            mimeType = 'audio/mp4';
          } else if (fileExtension === '.webm') {
            mimeType = 'audio/webm; codecs=opus';
          }
          
          // Criar data URI completo
          const audioDataUri = `data:${mimeType};base64,${audioBase64}`;
          
          // Tentar enviar como PTT/Voice
          console.log('üé§ Tentando enviar como mensagem de voz...');
          
          // M√©todo 1: sendPttFromBase64 (mais comum no wppconnect)
          if (session.client.sendPttFromBase64) {
            result = await session.client.sendPttFromBase64(
              to,
              audioBase64,
              'voice-message'
            );
            console.log('‚úÖ √Åudio enviado via sendPttFromBase64');
          }
          // M√©todo 2: sendVoice 
          else if (session.client.sendVoice) {
            result = await session.client.sendVoice(
              to,
              audioDataUri
            );
            console.log('‚úÖ √Åudio enviado via sendVoice');
          }
          // M√©todo 3: sendAudio com flag PTT
          else if (session.client.sendAudio) {
            result = await session.client.sendAudio(
              to,
              audioDataUri,
              'voice-message',
              '',
              true // flag PTT
            );
            console.log('‚úÖ √Åudio enviado via sendAudio com flag PTT');
          }
          // M√©todo 4: sendFile com mimetype de √°udio
          else {
            console.log('‚ö†Ô∏è Nenhum m√©todo de √°udio nativo encontrado, usando sendFile...');
            result = await session.client.sendFile(
              to,
              audioDataUri,
              'voice-message',
              'üéµ Mensagem de voz'
            );
            console.log('‚úÖ √Åudio enviado via sendFile');
          }
          
          console.log('‚úÖ √Åudio PTT enviado com sucesso');
          
        } catch (audioError) {
          console.error('‚ùå sendPtt falhou:', audioError.message);
          
          // FALLBACK 1: Tentar sendVoice se existir
          try {
            if (session.client.sendVoice) {
              console.log('üé§ Tentando sendVoice...');
              result = await session.client.sendVoice(
                to,
                options.path
              );
              console.log('‚úÖ √Åudio enviado via sendVoice');
            } else {
              throw new Error('sendVoice n√£o dispon√≠vel');
            }
          } catch (voiceError) {
            console.error('‚ùå sendVoice falhou:', voiceError.message);
            
            // FALLBACK 2: Enviar como arquivo comum
            try {
              console.log('üìÑ Tentando como arquivo comum...');
              result = await session.client.sendFile(
                to, 
                options.path, 
                'voice-message.ogg',
                'üéµ Mensagem de voz'
              );
              console.log('‚úÖ √Åudio enviado como arquivo');
            } catch (fileError) {
              console.error('‚ùå Envio como arquivo tamb√©m falhou:', fileError.message);
              throw new Error(`Falha completa no envio de √°udio: ${audioError.message}`);
            }
          }
        }
        
      } else if (options.type === 'video' && options.path) {
        console.log('üé• Enviando v√≠deo:', options.path);
        result = await session.client.sendVideoAsGif(to, options.path, options.filename || 'video', content || '');
        
      } else {
        // Mensagem de texto
        let finalContent = content || '';
        if (options.signature) {
          finalContent += `\n\n_${options.signature}_`;
        }
        
        // Verificar se o conte√∫do n√£o est√° vazio
        if (!finalContent.trim()) {
          finalContent = 'üìù Mensagem enviada';
        }
        
        result = await session.client.sendText(to, finalContent);
      }

      console.log('‚úÖ Mensagem enviada com sucesso');
      
      return {
        success: true,
        messageId: result?.id || result?._serialized || 'temp_' + Date.now()
      };

    } catch (error) {
      console.error('‚ùå Erro ao enviar mensagem:', error.message);
      throw new Error(`Falha no envio: ${error.message}`);
    }
  }

  // Lidar com QR Code
  async handleQRCode(sessionId, qrCode) {
    await db.sessions.update(sessionId, {
      qrcode: qrCode,
      status: 'connecting'
    });

    this.io.emit('session:qr', {
      sessionId,
      qrCode
    });
  }

  // Lidar com mudan√ßa de status
  async handleStatus(sessionId, status) {
    let dbStatus = 'disconnected';
    
    if (status === 'isLogged' || status === 'inChat') {
      dbStatus = 'connected';
    } else if (status === 'qrReadSuccess' || status === 'isConnecting') {
      dbStatus = 'connecting';
    }

    await db.sessions.update(sessionId, { status: dbStatus });
    
    this.io.emit('session:status', {
      sessionId,
      status: dbStatus
    });
  }

  // Lidar com desconex√£o
  async handleDisconnect(sessionId) {
    const session = sessions.get(sessionId);
    if (session && session.client) {
      try {
        await session.client.close();
      } catch (error) {
        console.error('Erro ao fechar cliente:', error);
      }
    }

    // Limpar recursos espec√≠ficos da sess√£o
    if (session) {
      await this.cleanupSessionResources(sessionId, session.name);
    }

    sessions.delete(sessionId);
    
    await db.sessions.update(sessionId, {
      status: 'disconnected',
      qrcode: null
    });

    this.io.emit('session:disconnected', { sessionId });
    console.log(`üîå Sess√£o ${sessionId} desconectada e recursos limpos`);
  }

  // Desconectar sess√£o
  async disconnectSession(sessionId) {
    await this.handleDisconnect(sessionId);
  }

  // Obter todas as sess√µes
  getSessions() {
    const activeSessions = [];
    sessions.forEach((session, id) => {
      activeSessions.push({
        id,
        name: session.name,
        status: session.status
      });
    });
    return activeSessions;
  }

  // Verificar se sess√£o est√° ativa
  isSessionActive(sessionId) {
    return sessions.has(sessionId);
  }

  // Obter cliente da sess√£o
  getClient(sessionId) {
    const session = sessions.get(sessionId);
    return session ? session.client : null;
  }
  
  // Verificar e processar enquetes ativas
  async checkActivePoll(contactId, messageText) {
    try {
      // Buscar enquete ativa para este contato
      const activePoll = await db.polls.findActiveByContact(contactId);
      
      if (!activePoll) {
        return false;
      }
      
      // Verificar se expirou
      if (activePoll.expires_at && new Date() > new Date(activePoll.expires_at)) {
        await db.polls.updateStatus(activePoll.id, 'expired');
        return false;
      }
      
      // Verificar se j√° respondeu
      const hasResponded = await db.pollResponses.hasResponded(activePoll.id, contactId);
      if (hasResponded) {
        return false;
      }
      
      // Processar resposta
      const response = await this.processPollResponse(activePoll, messageText);
      if (response) {
        // Salvar resposta
        await db.pollResponses.create({
          poll_id: activePoll.id,
          contact_id: contactId,
          selected_options: response.selectedOptions,
          response_text: messageText
        });
        
        // Enviar confirma√ß√£o
        await this.sendPollConfirmation(activePoll, response, contactId);
        
        console.log(`‚úÖ Resposta de enquete processada para contato ${contactId}`);
        return true;
      }
      
      return false;
      
    } catch (error) {
      console.error('Erro ao verificar enquete ativa:', error);
      return false;
    }
  }

  // Processar resposta da enquete
  async processPollResponse(poll, messageText) {
    try {
      const cleanText = messageText.trim().toLowerCase();
      const selectedOptions = [];
      
      // Verificar se √© resposta num√©rica
      const numbers = cleanText.match(/\d+/g);
      if (numbers) {
        for (const num of numbers) {
          const optionIndex = parseInt(num);
          if (optionIndex >= 1 && optionIndex <= poll.options.length) {
            selectedOptions.push(optionIndex);
            
            // Para enquete de escolha √∫nica, parar no primeiro n√∫mero v√°lido
            if (poll.poll_type === 'single') {
              break;
            }
          }
        }
      }
      
      // Se n√£o encontrou n√∫meros v√°lidos, tentar buscar por texto
      if (selectedOptions.length === 0) {
        for (let i = 0; i < poll.options.length; i++) {
          const option = poll.options[i].toLowerCase();
          if (cleanText.includes(option) || option.includes(cleanText)) {
            selectedOptions.push(i + 1);
            if (poll.poll_type === 'single') {
              break;
            }
          }
        }
      }
      
      if (selectedOptions.length === 0) {
        return null; // Resposta inv√°lida
      }
      
      // Para enquete m√∫ltipla, remover duplicatas
      const uniqueOptions = [...new Set(selectedOptions)];
      
      return {
        selectedOptions: uniqueOptions,
        optionTexts: uniqueOptions.map(index => poll.options[index - 1])
      };
      
    } catch (error) {
      console.error('Erro ao processar resposta da enquete:', error);
      return null;
    }
  }

  // Enviar confirma√ß√£o da resposta
  async sendPollConfirmation(poll, response, contactId) {
    try {
      const contact = await db.query('SELECT number FROM contacts WHERE id = ?', [contactId]);
      if (!contact.length) return;
      
      const selectedTexts = response.optionTexts.join(', ');
      const message = `‚úÖ *Resposta registrada!*\n\n` +
                     `üìä **${poll.question}**\n\n` +
                     `Sua resposta: ${selectedTexts}\n\n` +
                     `_Obrigado por participar!_`;
      
      // Buscar sess√£o ativa
      const sessions = await db.sessions.list();
      const activeSession = sessions.find(s => s.status === 'connected');
      
      if (activeSession) {
        await this.sendMessage(activeSession.id, contact[0].number, message);
      }
      
    } catch (error) {
      console.error('Erro ao enviar confirma√ß√£o da enquete:', error);
    }
  }

  // Enviar enquete para contato
  async sendPollToContact(sessionId, contactNumber, pollData) {
    try {
      let message = `üìä *${pollData.question}*\n\n`;
      
      pollData.options.forEach((option, index) => {
        const emoji = pollData.poll_type === 'single' ? 'üîò' : '‚òê';
        message += `${emoji} ${index + 1}. ${option}\n`;
      });
      
      message += `\n_Responda com o n√∫mero da op√ß√£o`;
      if (pollData.poll_type === 'multiple') {
        message += ' (pode escolher v√°rias separadas por v√≠rgula)';
      }
      message += '_';
      
      if (pollData.expires_at) {
        const expiresDate = new Date(pollData.expires_at);
        message += `\n\n‚è∞ _Expira em: ${expiresDate.toLocaleString('pt-BR')}_`;
      }
      
      const result = await this.sendMessage(sessionId, contactNumber, message);
      
      // Atualizar enquete com message_id se dispon√≠vel
      if (result.messageId && pollData.id) {
        await db.query('UPDATE polls SET message_id = ? WHERE id = ?', [result.messageId, pollData.id]);
      }
      
      return result;
      
    } catch (error) {
      console.error('Erro ao enviar enquete:', error);
      throw error;
    }
  }

  // Limpeza peri√≥dica do cache de mensagens autom√°ticas
  startCacheCleanup() {
    setInterval(() => {
      const now = Date.now();
      const maxAge = 3600000; // 1 hora
      
      for (const [key, timestamp] of lastAutoMessages.entries()) {
        if (now - timestamp > maxAge) {
          lastAutoMessages.delete(key);
        }
      }
      
      console.log(`üßπ Cache de mensagens autom√°ticas limpo. Entradas restantes: ${lastAutoMessages.size}`);
    }, 1800000); // Limpar a cada 30 minutos
  }
}

// Exportar a classe
module.exports = WhatsAppService;